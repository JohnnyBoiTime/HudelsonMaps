<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HudelMaps 3D – Pullman Road Graph</title>
  <!-- CesiumJS CSS -->
  <link
    href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css"
    rel="stylesheet"
  />

  <style>
    /* basic page layout stuff */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
    }

    #app {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    #sidebar {
      width: 280px;
      padding: 14px 16px;
      box-sizing: border-box;
      border-right: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.72);
      backdrop-filter: blur(10px);
      z-index: 10;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #sidebar h1 {
      margin: 0 0 4px;
      font-size: 18px;
      letter-spacing: 0.03em;
    }

    #sidebar p {
      margin: 0;
      font-size: 13px;
      color: #cbd5f5;
    }

    #sidebar .metric {
      font-size: 12px;
      margin-top: 4px;
      line-height: 1.4;
      color: #e5e7eb;
    }

    #sidebar button {
      width: 100%;
      padding: 6px 8px;
      margin-top: 6px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top left,
        rgba(248, 250, 252, 0.12),
        rgba(15, 23, 42, 0.9));
      color: #f9fafb;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }

    #sidebar button:hover {
      background: radial-gradient(circle at top left,
        rgba(248, 250, 252, 0.18),
        rgba(15, 23, 42, 0.95));
      box-shadow: 0 0 12px rgba(248, 250, 252, 0.25);
      transform: translateY(-1px);
    }

    #sidebar button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    #metrics {
      margin-top: 2px;
      padding-top: 4px;
      border-top: 1px solid rgba(148, 163, 184, 0.35);
    }

    .credit {
      font-size: 10px;
      color: #9ca3af;
      margin-top: auto;
      padding-top: 6px;
      border-top: 1px solid rgba(148, 163, 184, 0.35);
    }

    #cesiumContainer {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .cesium-viewer {
      background: #020617;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h1>HudelMaps 3D</h1>
      <p>
        Click two points on Pullman. We snap to the nearest graph nodes,
        run Dijkstra on your road graph, and animate the shortest path search in 3D.
      </p>
      <p class="metric" id="statusText">Loading Cesium…</p>
      <p class="metric" id="metricsPanel"></p>

      <button id="resetButton">Reset selection</button>
      <button id="whereAmIButton">Go to current location</button>
      <button id="toggleAnimationButton">Animation: ON</button>
      <button id="startFromUserButton">Start path from user</button>
      <button id="toggleEdgesButton">Toggle full graph</button>

      <div class="credit">
        Data: Pullman road graph<br />
        Engine: CesiumJS + World Terrain
      </div>
    </div>
    <div id="cesiumContainer"></div>
  </div>

  <!-- Cesium script itself -->
  <script
    src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js">
  </script>

  <script>
    // NOTE: this is my personal Cesium ion token for this class project.
    // If it ever breaks, it's probably because the token got rotated.
    Cesium.Ion.defaultAccessToken =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzNzEzNDBkMi03NmQ5LTQ3MjUtOTljNC00OTllY2I1ZjliY2YiLCJpZCI6MzY3MjkxLCJpYXQiOjE3NjUwNjg5MDR9.-7d8bj9ytmFGe9tm2kmpjfBcaNJwS-jGoiPNg7RBTdo";

    // grab the little text areas + buttons from the sidebar
    const statusText            = document.getElementById("statusText");
    const metricsPanel          = document.getElementById("metricsPanel");
    const resetButton           = document.getElementById("resetButton");
    const whereAmIButton        = document.getElementById("whereAmIButton");
    const toggleEdgesButton     = document.getElementById("toggleEdgesButton");
    const toggleAnimationButton = document.getElementById("toggleAnimationButton");
    const startFromUserButton   = document.getElementById("startFromUserButton");

    // some rough constants to make the sidebar more informative
    const WALK_SPEED_M_PER_SEC = 1.4; // average human walk speed.
    const STEP_DELAY_MS = 3;          // delay for each Dijkstra "visit"
    const EDGE_DELAY_MS = 1;          // delay for each edge relaxation

    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

    // Cesium viewer and graph data live in these globals.
    let viewerInstance;
    let graphNodes = [];
    let graphEdges = [];
    let nodesById = new Map();
    let adjacencyList = new Map();

    // currently selected start/end nodes (ids from the JSON)
    let startNodeId = null;
    let endNodeId   = null;

    // entities for visuals that we want to be able to clear / toggle
    let roadSegments = [];      // all road polylines
    let nodeLabelEntities = []; // labels (only for named nodes)
    let pathPolyline = null;    // final shortest path

    let exploredEdges = [];     // orange edges explored during Dijkstra
    let currentNodeDot = null;  // white dot showing "current" node in animation
    let showAllEdges = true;
    let dijkstraIsRunning = false;
    let animateDijkstra = true; // we can flip this from the toggle button

    // user-location state
    let userMarker = null;
    let userLongitude = null;
    let userLatitude = null;
    let geoWatchId = null;
    let hasCenteredOnUser = false;
    let startPathFromUser = false;

    // Set up viewer
    function setupCesiumViewer() {
      // basic Cesium viewer config – I turned off a bunch of UI I don't need
      viewerInstance = new Cesium.Viewer("cesiumContainer", {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        animation: false,
        timeline: false,
        sceneModePicker: false,
        baseLayerPicker: true,
        geocoder: false,
        selectionIndicator: false,
        infoBox: false,
        navigationHelpButton: false
      });

      // turning on lighting so the globe doesn't look totally flat
      viewerInstance.scene.globe.enableLighting = true;

      // this is roughly centered over Pullman campus
      viewerInstance.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(-117.165, 46.731, 2200.0),
        orientation: {
          heading: Cesium.Math.toRadians(-20.0),
          pitch:   Cesium.Math.toRadians(-50.0),
          roll:    0.0
        }
      });

      statusText.textContent = "Loading graph JSON (nodes + edges)…";
    }

    // Load Graph
    async function loadGraphJson() {
      // this JSON file is what Calvin made from the actual Pullman map
      const response = await fetch("Full_Pullman_Road_Graph_Data.json");
      const graphData = await response.json();

      graphNodes = graphData.nodes;
      graphEdges = graphData.edges;

      // simple id → node lookup
      nodesById = new Map(graphNodes.map(node => [node.id, node]));

      // convert edges into an adjacency list so Dijkstra is easier to implement
      adjacencyList = buildAdjacencyList(graphNodes, graphEdges);

      statusText.textContent =
        `Graph loaded: ${graphNodes.length} nodes, ${graphEdges.length} edges`;

      // draw once, then just update selection/paths later
      drawAllRoads();
      drawLabelsForNamedNodes();
      setupMouseInteraction();
      setupGeolocationButtons();
    }

    function buildAdjacencyList(nodes, edges) {
      const adj = new Map();
      nodes.forEach(node => adj.set(node.id, []));
      edges.forEach(edge => {
        const weight = edge.distanceMeters || edge.distance || 0;
        adj.get(edge.from).push({ to: edge.to, weight });
        adj.get(edge.to).push({ to: edge.from, weight });  // undirected graph
      });
      return adj;
    }

    // Drawing roads and labels
    function drawAllRoads() {
      clearAllRoadPolylines();

      roadSegments = graphEdges.map(edge => {
        const a = nodesById.get(edge.from);
        const b = nodesById.get(edge.to);
        if (!a || !b) {
          // if something is off in the JSON, just log it and skip the edge
          console.warn("Missing node for edge", edge);
          return null;
        }

        return viewerInstance.entities.add({
          polyline: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              a.lng, a.lat,
              b.lng, b.lat
            ]),
            width: 3.5,
            // this is the general "graph skeleton" color
            material: Cesium.Color.fromCssColorString("#1f6feb"),
            clampToGround: true
          }
        });
      }).filter(entity => entity !== null);
    }

    function clearAllRoadPolylines() {
      if (!viewerInstance) return;
      roadSegments.forEach(entity => viewerInstance.entities.remove(entity));
      roadSegments = [];
    }

    function setRoadVisibility(visible) {
      roadSegments.forEach(entity => entity.show = visible);
      nodeLabelEntities.forEach(entity => entity.show = visible);
    }

    function drawLabelsForNamedNodes() {
      nodeLabelEntities.forEach(entity => viewerInstance.entities.remove(entity));
      nodeLabelEntities = [];

      graphNodes.forEach(node => {
        // only show labels for nodes that actually have a "name" field
        if (!node.name) return;

        const labelEntity = viewerInstance.entities.add({
          position: Cesium.Cartesian3.fromDegrees(node.lng, node.lat),
          label: {
            text: node.name,
            font: "13px 'Segoe UI', sans-serif",
            fillColor: Cesium.Color.WHITE,
            showBackground: true,
            backgroundColor: Cesium.Color.fromAlpha(Cesium.Color.BLACK, 0.65),
            pixelOffset: new Cesium.Cartesian2(0, -18),
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            scaleByDistance: new Cesium.NearFarScalar(1200, 1.0, 6000, 0.0),
            translucencyByDistance: new Cesium.NearFarScalar(1200, 1.0, 6000, 0.0)
          }
        });

        nodeLabelEntities.push(labelEntity);
      });
    }

    // Exploration visuals animated for Dijkstra
    function clearExplorationVisuals() {
      exploredEdges.forEach(entity => viewerInstance.entities.remove(entity));
      exploredEdges = [];
      if (currentNodeDot) {
        viewerInstance.entities.remove(currentNodeDot);
        currentNodeDot = null;
      }
    }

    function showCurrentNodeMarker(nodeId) {
      if (currentNodeDot) {
        viewerInstance.entities.remove(currentNodeDot);
        currentNodeDot = null;
      }
      const node = nodesById.get(nodeId);
      if (!node) return;

      currentNodeDot = viewerInstance.entities.add({
        position: Cesium.Cartesian3.fromDegrees(node.lng, node.lat),
        point: {
          pixelSize: 10,
          color: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.fromCssColorString("#5ec8ff"),
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        }
      });
    }

    function addExploredEdge(fromId, toId) {
      const a = nodesById.get(fromId);
      const b = nodesById.get(toId);
      if (!a || !b) return;

      const explored = viewerInstance.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray([a.lng, a.lat, b.lng, b.lat]),
          width: 4,
          material: new Cesium.PolylineGlowMaterialProperty({
            glowPower: 0.25,
            color: Cesium.Color.ORANGE.withAlpha(0.9)
          }),
          clampToGround: true
        }
      });
      exploredEdges.push(explored);
    }

    // Dijkstra (no animation)
    function runDijkstraInstant(startId, endId) {
      const distances = new Map();
      const previous  = new Map();
      const remaining = new Set(adjacencyList.keys());

      adjacencyList.forEach((_, id) => distances.set(id, Infinity));
      distances.set(startId, 0);

      while (remaining.size > 0) {
        let bestNode = null;
        let bestDist = Infinity;
        for (const nodeId of remaining) {
          const d = distances.get(nodeId);
          if (d < bestDist) {
            bestDist = d;
            bestNode = nodeId;
          }
        }

        if (bestNode === null || bestDist === Infinity) break;
        remaining.delete(bestNode);
        if (bestNode === endId) break;

        const neighbors = adjacencyList.get(bestNode) || [];
        for (const { to, weight } of neighbors) {
          if (!remaining.has(to)) continue;
          const alt = bestDist + weight;
          if (alt < distances.get(to)) {
            distances.set(to, alt);
            previous.set(to, bestNode);
          }
        }
      }

      const path = [];
      let cur = endId;
      if (!previous.has(cur) && cur !== startId) {
        // no path found
        return { path: [], distance: Infinity };
      }

      while (cur !== undefined) {
        path.unshift(cur);
        if (cur === startId) break;
        cur = previous.get(cur);
      }

      return { path, distance: distances.get(endId) };
    }

    // Dijkstra (animated)
    async function runDijkstraWithAnimation(startId, endId) {
      dijkstraIsRunning = true;
      clearExplorationVisuals();
      clearShortestPath();

      const distances = new Map();
      const previous  = new Map();
      const remaining = new Set(adjacencyList.keys());

      adjacencyList.forEach((_, id) => distances.set(id, Infinity));
      distances.set(startId, 0);

      let stepCounter = 0;

      while (remaining.size > 0) {
        let bestNode = null;
        let bestDist = Infinity;
        for (const nodeId of remaining) {
          const d = distances.get(nodeId);
          if (d < bestDist) {
            bestDist = d;
            bestNode = nodeId;
          }
        }

        if (bestNode === null || bestDist === Infinity) break;
        remaining.delete(bestNode);

        stepCounter += 1;
        showCurrentNodeMarker(bestNode);
        statusText.textContent =
          `Dijkstra step ${stepCounter}: visiting node ${bestNode} (dist ≈ ${bestDist.toFixed(1)} m)`;
        await wait(STEP_DELAY_MS);

        if (bestNode === endId) break;

        const neighbors = adjacencyList.get(bestNode) || [];
        for (const { to, weight } of neighbors) {
          if (!remaining.has(to)) continue;

          const alt = bestDist + weight;
          if (alt < distances.get(to)) {
            distances.set(to, alt);
            previous.set(to, bestNode);
            // visually show that we found a "better" way to reach this neighbor
            addExploredEdge(bestNode, to);
            await wait(EDGE_DELAY_MS);
          }
        }
      }

      const path = [];
      let cur = endId;
      if (!previous.has(cur) && cur !== startId) {
        dijkstraIsRunning = false;
        return { path: [], distance: Infinity };
      }

      while (cur !== undefined) {
        path.unshift(cur);
        if (cur === startId) break;
        cur = previous.get(cur);
      }

      const finalDistance = distances.get(endId);
      dijkstraIsRunning = false;
      return { path, distance: finalDistance };
    }

    // Path rendering and metrics
    function clearShortestPath() {
      if (pathPolyline && viewerInstance) {
        viewerInstance.entities.remove(pathPolyline);
        pathPolyline = null;
      }
      metricsPanel.textContent = "";
    }

    function drawShortestPath(pathIds, totalDistanceMeters) {
      clearShortestPath();
      if (!pathIds || pathIds.length === 0) return;

      const rawCoords = [];
      pathIds.forEach(id => {
        const node = nodesById.get(id);
        rawCoords.push(node.lng, node.lat);
      });

      pathPolyline = viewerInstance.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray(rawCoords),
          width: 12,
          material: new Cesium.PolylineGlowMaterialProperty({
            glowPower: 0.8,
            color: Cesium.Color.fromCssColorString("#8fd4ff")
          }),
          clampToGround: true
        }
      });

      // quick and dirty walking time estimate
      const timeMinutes = (totalDistanceMeters / WALK_SPEED_M_PER_SEC) / 60 * 1.4;
      metricsPanel.innerHTML =
        `<strong>Path length:</strong> ${totalDistanceMeters.toFixed(1)} m<br>` +
        `<strong>Est. walk time:</strong> ${timeMinutes.toFixed(1)} min<br>` +
        `<strong>Nodes on path:</strong> ${pathIds.length}`;
    }

    // Mouse interaction
    function setupMouseInteraction() {
      const eventHandler = new Cesium.ScreenSpaceEventHandler(
        viewerInstance.scene.canvas
      );

      eventHandler.setInputAction(async function(click) {
        if (dijkstraIsRunning) {
          statusText.textContent = "Dijkstra is already running, hang on a sec…";
          return;
        }

        const cartesian = viewerInstance.scene.pickPosition(click.position) ||
          viewerInstance.camera.pickEllipsoid(
            click.position,
            viewerInstance.scene.globe.ellipsoid
          );

        if (!cartesian) return;

        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        const lonDeg = Cesium.Math.toDegrees(cartographic.longitude);
        const latDeg = Cesium.Math.toDegrees(cartographic.latitude);

        const nearestId = findNearestNode(lonDeg, latDeg);
        if (nearestId === null) return;

        // Special mode: start from user's nearest node
        if (startPathFromUser && userLatitude !== null && userLongitude !== null) {
          const userStartId = findNearestNode(userLongitude, userLatitude);
          startNodeId = userStartId;
          endNodeId = nearestId;

          statusText.textContent =
            `Start: user location (node ${startNodeId}), End: ${endNodeId}. ` +
            (animateDijkstra ? "Running Dijkstra with animation…" : "Computing shortest path…");

          let result;
          if (animateDijkstra) {
            result = await runDijkstraWithAnimation(startNodeId, endNodeId);
          } else {
            clearExplorationVisuals();
            result = runDijkstraInstant(startNodeId, endNodeId);
          }

          if (!result.path.length || !isFinite(result.distance)) {
            statusText.textContent = "No path found between those nodes.";
            clearShortestPath();
            return;
          }

          statusText.textContent =
            `Shortest path found (${result.path.length} nodes).`;
          drawShortestPath(result.path, result.distance);
          return;
        }

        // Normal click flow:
        // 1st click → start
        // 2nd click → end + run algorithm
        // 3rd click → treat as new start
        if (startNodeId === null) {
          startNodeId = nearestId;
          endNodeId = null;
          clearExplorationVisuals();
          clearShortestPath();
          statusText.textContent =
            `Start node set to ${startNodeId}. Click another point for the destination.`;
        } else if (endNodeId === null) {
          endNodeId = nearestId;
          statusText.textContent =
            `Start: ${startNodeId}, End: ${endNodeId}. ` +
            (animateDijkstra ? "Running Dijkstra with animation…" : "Computing shortest path (instant)…");

          let result;
          if (animateDijkstra) {
            result = await runDijkstraWithAnimation(startNodeId, endNodeId);
          } else {
            clearExplorationVisuals();
            result = runDijkstraInstant(startNodeId, endNodeId);
          }

          if (!result.path.length || !isFinite(result.distance)) {
            statusText.textContent = "No path found between those nodes.";
            clearShortestPath();
            return;
          }

          statusText.textContent =
            `Shortest path found (${result.path.length} nodes).`;
          drawShortestPath(result.path, result.distance);
        } else {
          // 3rd click → reset the start node to whatever was clicked
          startNodeId = nearestId;
          endNodeId = null;
          clearExplorationVisuals();
          clearShortestPath();
          statusText.textContent =
            `Start node changed to ${startNodeId}. Click again to pick a new destination.`;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // Reset button: clear everything and go back to the "loaded" state
      resetButton.addEventListener("click", () => {
        if (dijkstraIsRunning) return;
        startNodeId = null;
        endNodeId = null;
        clearExplorationVisuals();
        clearShortestPath();
        statusText.textContent =
          `Graph loaded: ${graphNodes.length} nodes, ${graphEdges.length} edges.`;
      });

      // Hide/show the full road graph
      toggleEdgesButton.addEventListener("click", () => {
        showAllEdges = !showAllEdges;
        setRoadVisibility(showAllEdges);
      });

      // Flip between animated and non-animated Dijkstra
      toggleAnimationButton.addEventListener("click", () => {
        animateDijkstra = !animateDijkstra;
        toggleAnimationButton.textContent =
          `Animation: ${animateDijkstra ? "ON" : "OFF"}`;
      });
    }

    function setupGeolocationButtons() {
      whereAmIButton.addEventListener("click", () => {
        if (!navigator.geolocation) {
          alert("Your browser does not support geolocation.");
          return;
        }

        // clear any old watch
        if (geoWatchId !== null) {
          navigator.geolocation.clearWatch(geoWatchId);
          geoWatchId = null;
        }

        geoWatchId = navigator.geolocation.watchPosition(
          handleGeolocationSuccess,
          handleGeolocationError,
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
          }
        );
      });

      startFromUserButton.addEventListener("click", () => {
        startPathFromUser = !startPathFromUser;
        startFromUserButton.textContent = startPathFromUser
          ? "Start path from user"
          : "Start path from first click";
      });
    }

    function handleGeolocationSuccess(position) {
      userLatitude  = position.coords.latitude;
      userLongitude = position.coords.longitude;

      const userCartesian = Cesium.Cartesian3.fromDegrees(userLongitude, userLatitude);

      if (!userMarker) {
        userMarker = viewerInstance.entities.add({
          position: userCartesian,
          point: {
            pixelSize: 16,
            color: Cesium.Color.RED,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          }
        });
      } else {
        userMarker.position = userCartesian;
      }

      // Automatically fly to the user once
      if (!hasCenteredOnUser) {
        viewerInstance.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            userLongitude,
            userLatitude,
            1500.0
          ),
          duration: 1.5
        });
        hasCenteredOnUser = true;
      }
    }

    function handleGeolocationError(error) {
      console.error("Error getting user location", error);
      alert("Could not get your current location: " + error.message);

      if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
    }

    function findNearestNode(lonDeg, latDeg) {
      let bestId = null;
      let bestDist = Number.POSITIVE_INFINITY;

      for (const node of graphNodes) {
        const dLon = lonDeg - node.lng;
        const dLat = latDeg - node.lat;
        const distance = Math.sqrt(dLon * dLon + dLat * dLat);
        if (distance < bestDist) {
          bestDist = distance;
          bestId = node.id;
        }
      }
      return bestId;
    }

    (async function startApp() {
      try {
        setupCesiumViewer();
        await loadGraphJson();
      } catch (err) {
        console.error("Error bootstrapping Cesium or the graph:", err);
        statusText.textContent = "Error loading Cesium or graph data (see console).";
      }
    })();
  </script>
</body>
</html>
