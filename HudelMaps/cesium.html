<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HudelMaps 3D – Pullman Road Graph</title>
  <!-- CesiumJS CSS -->
  <link href="styles.css" rel="stylesheet">
  <link
    href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css"
    rel="stylesheet"
  />
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h1>HudelMaps 3D</h1>
      <p>
        Click two points on Pullman. We snap to the nearest graph nodes,
        run Dijkstra on your road graph, and animate the shortest path search in 3D.
      </p>
      <p class="metric" id="statusText">Loading Cesium…</p>
      <p class="metric" id="metricsPanel"></p>

      <button id="resetButton">Reset selection</button>
      <button id="whereAmIButton">Go to current location</button>
      <button id="toggleAnimationButton">Animation: OFF</button>
      <button id="startFromUserButton">Start path from user</button>
      <button id="toggleEdgesButton">Toggle full graph</button>
      <br>

      <h4>Pullman & Campus Locations</h4>
      <div class="images" id="imageContainer"></div>

      <div class="credit">
        Data: Pullman road graph<br />
        Engine: CesiumJS + World Terrain
      </div>
    </div>
    <div id="cesiumContainer" class></div>
  </div>

  <!-- Cesium script itself -->
  <script
    src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js">
  </script>

  <script>
    const images = [
      { url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSCElFL5LdbDM6HHPN1pUax3jA3jzU_JLDTYA&s", name: "Wilson-Short Hall", lat: 46.730506, long: -117.162511 },
      { url: "https://cub.wsu.edu/media/ylldyygf/cub-summer-exterior-header.jpg", name: "The CUB", lat: 46.730805, long: -117.163011 },
      { url: "https://pbs.twimg.com/media/Fa3kVn7VUAAjcNz.jpg", name: "Webster", lat: 46.728899, long: -117.163790 },
      { url: "https://wpcdn.web.wsu.edu/wp-global/uploads/sites/3508/2017/11/zu_WSU_SPARK_47_990x532_small.jpg", name: "The Spark", lat: 46.728204, long: -117.165412 },
      { url: "https://libraries.wsu.edu/sites/default/files/holnewpict.jpg", name: "Terrell Library", lat: 46.730772, long: -117.163482 },
      { url: "https://wpcdn.web.wsu.edu/wp-ip/uploads/sites/2794/2022/03/Bryan-at-dusk.jpeg", name: "Bryan Hall", lat: 46.731348, long: -117.164829 },
      { url: "https://urec.wsu.edu/media/jmca0xrs/chinook-exterior.jpg", name: "The Chinook", lat: 46.732540, long: -117.165612 },
      { url: "https://www.heraldnews.com/gcdn/authoring/2016/12/02/NHER/ghows-WL-1660ba17-89ae-47d1-bc04-2e5eb9abc009-b034fa13.jpeg?crop=842,632,x51,y0", name: "Stadium Way McDonalds", lat: 46.73948999915676, long: -117.17110852573683},
      { url: "https://assets.simpleviewinc.com/simpleview/image/upload/c_fill,h_396,q_75,w_704/v1/crm/pullmanwa/contribution_gallery_480B7DBA-F58E-9CEA-073CD1B888C453E0-480b7cdbc83a9fc_480b86f8-ec44-ded2-e8b4069fd279b76d.jpg", name: "Taco Bell", lat: 46.738815, long: -117.171113 },
      { url: "https://libraries.wsu.edu/wp-content/uploads/files/paul_brians/palouse/moscow/moscowwelcome.jpg", name: "Moscow", lat: 46.732389, long: -117.039748 },
      { url: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Jewett_Observatory_01-04-15.jpg/1200px-Jewett_Observatory_01-04-15.jpg", name: "Jewett Observatory", lat: 46.728595, long: -117.153637 },
    ]

    // NOTE: this is my personal Cesium ion token for this class project.
    // If it ever breaks, it's probably because the token got rotated.
    Cesium.Ion.defaultAccessToken =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzNzEzNDBkMi03NmQ5LTQ3MjUtOTljNC00OTllY2I1ZjliY2YiLCJpZCI6MzY3MjkxLCJpYXQiOjE3NjUwNjg5MDR9.-7d8bj9ytmFGe9tm2kmpjfBcaNJwS-jGoiPNg7RBTdo";

    // grab the little text areas + buttons from the sidebar
    const statusText            = document.getElementById("statusText");
    const metricsPanel          = document.getElementById("metricsPanel");
    const resetButton           = document.getElementById("resetButton");
    const whereAmIButton        = document.getElementById("whereAmIButton");
    const toggleEdgesButton     = document.getElementById("toggleEdgesButton");
    const toggleAnimationButton = document.getElementById("toggleAnimationButton");
    const startFromUserButton   = document.getElementById("startFromUserButton");

    // some rough constants to make the sidebar more informative
    const walkSpeedOfNormalHumanBeing = 1.4; // average human walk speed.

    // Cesium viewer and graph data live in these globals.
    let viewerInstance;
    let graphNodes = [];
    let graphEdges = [];
    let nodesById = new Map();
    let adjacencyList = new Map();

    // currently selected start/end nodes (ids from the JSON)
    let startNodeId = null;
    let endNodeId   = null;

    // entities for visuals that we want to be able to clear / toggle
    let roadSegments = [];      // all road polylines
    let nodeLabelEntities = []; // labels (only for named nodes)
    let pathPolyline = null;    // final shortest path

    let exploredEdges = [];     // orange edges explored during Dijkstra
    let currentNodeDot = null;  // white dot showing "current" node in animation
    let showAllEdges = true;
    let dijkstraIsRunning = false;
    let animateDijkstra = false; // we can flip this from the toggle button

    // user-location state
    let userMarker = null;
    let userLongitude = null;
    let userLatitude = null;
    let usersLocation = null;
    let hasCenteredOnUser = false;
    let startPathFromUser = false;

    const wait  = (ms) => {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      })
    }

    // Set up viewer
    function setupCesiumViewer() {
      // basic Cesium viewer config – I turned off a bunch of UI I don't need
      viewerInstance = new Cesium.Viewer("cesiumContainer", {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        animation: false,
        timeline: false,
        sceneModePicker: false,
        baseLayerPicker: true,
        geocoder: false,
        selectionIndicator: false,
        infoBox: false,
        navigationHelpButton: false
      });

      // turning on lighting so the globe doesn't look totally flat
      viewerInstance.scene.globe.enableLighting = true;

      // this is roughly centered over Pullman campus
      viewerInstance.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(-117.165, 46.731, 2200.0),
        orientation: {
          heading: Cesium.Math.toRadians(-20.0),
          pitch:   Cesium.Math.toRadians(-50.0),
          roll:    0.0
        }
      });

      statusText.textContent = "Loading graph JSON (nodes + edges)…";
    }

    // Load Graph
    async function loadGraphJson() {
      // this JSON file is what Calvin made from the actual Pullman map
      const response = await fetch("Full_Pullman_Road_Graph_Data.json");
      const graphData = await response.json();

      graphNodes = graphData.nodes;
      graphEdges = graphData.edges;

      // simple id → node lookup
      nodesById = new Map(graphNodes.map(node => [node.id, node]));

      // convert edges into an adjacency list so Dijkstra is easier to implement
      adjacencyList = buildAdjacencyList(graphNodes, graphEdges);

      statusText.textContent =
        `Graph loaded: ${graphNodes.length} nodes, ${graphEdges.length} edges`;

      // draw once, then just update selection/paths later
      drawAllRoads();
      drawLabelsForNamedNodes();
      setupMouseInteraction();
      setupGeolocationButtons();
    }

    function buildAdjacencyList(nodes, edges) {
      const adjacencyList= new Map();
      nodes.forEach(node => adjacencyList.set(node.id, []));
      edges.forEach(edge => {
        const weight = edge.distanceMeters || edge.distance || 0;
        adjacencyList.get(edge.from).push({ to: edge.to, weight });
        adjacencyList.get(edge.to).push({ to: edge.from, weight });  // undirected graph
      });
      return adjacencyList;
    }

    // Drawing roads and labels
    function drawAllRoads() {
      clearAllRoadPolylines();

      roadSegments = graphEdges.map(edge => {
        const startingNode = nodesById.get(edge.from);
        const endingNode = nodesById.get(edge.to);
        if (!startingNode || !endingNode) {
          // if something is off in the JSON, just log it and skip the edge
          console.warn("Missing node for edge", edge);
          return null;
        }

        return viewerInstance.entities.add({
          polyline: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              startingNode.lng, startingNode.lat,
              endingNode.lng, endingNode.lat
            ]),
            width: 4,
            // this is the general "graph skeleton" color
            material: Cesium.Color.fromCssColorString("#60a5fa").withAlpha(0.75), 
            clampToGround: true
          }
        });
      }).filter(entity => entity !== null);
    }

    function clearAllRoadPolylines() {
      if (!viewerInstance) {
        return;
      }
      roadSegments.forEach(entity => viewerInstance.entities.remove(entity));
      roadSegments = [];
    }

    function setRoadVisibility(visible) {
      roadSegments.forEach(entity => entity.show = visible);
      nodeLabelEntities.forEach(entity => entity.show = visible);
    }

    function drawLabelsForNamedNodes() {
      nodeLabelEntities.forEach(entity => viewerInstance.entities.remove(entity));
      nodeLabelEntities = [];

      graphNodes.forEach(node => {
        // only show labels for nodes that actually have a "name" field
        if (!node.name) {
          return;
        }
        const labelEntity = viewerInstance.entities.add({
          position: Cesium.Cartesian3.fromDegrees(node.lng, node.lat),
          label: {
            text: node.name,
            font: "13px 'Segoe UI', sans-serif",
            fillColor: Cesium.Color.WHITE,
            showBackground: true,
            backgroundColor: Cesium.Color.fromAlpha(Cesium.Color.BLACK, 0.65),
            pixelOffset: new Cesium.Cartesian2(0, -18),
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            scaleByDistance: new Cesium.NearFarScalar(1200, 1.0, 6000, 0.0),
            translucencyByDistance: new Cesium.NearFarScalar(1200, 1.0, 6000, 0.0)
          }
        });

        nodeLabelEntities.push(labelEntity);
      });
    }

    // Exploration visuals animated for Dijkstra
    function clearExplorationVisuals() {
      exploredEdges.forEach(entity => viewerInstance.entities.remove(entity));
      exploredEdges = [];
      if (currentNodeDot) {
        viewerInstance.entities.remove(currentNodeDot);
        currentNodeDot = null;
      }
    }

    function showCurrentNodeMarker(nodeId) {
      if (currentNodeDot) {
        viewerInstance.entities.remove(currentNodeDot);
        currentNodeDot = null;
      }

      const node = nodesById.get(nodeId);
      if (!node) return;

      currentNodeDot = viewerInstance.entities.add({
        position: Cesium.Cartesian3.fromDegrees(node.lng, node.lat),
        point: {
          pixelSize: 16,
          color: Cesium.Color.fromCssColorString("#0A84FF"),      // same route blue
          outlineColor: Cesium.Color.fromCssColorString("#003E7C"),
          outlineWidth: 3,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(500, 1.5, 6000, 0.7)
        }
      });
    }


    function addExploredEdge(fromId, toId) {
      const startingNode = nodesById.get(fromId);
      const endingNode = nodesById.get(toId);
      if (!startingNode || !endingNode) return;

      const explored = viewerInstance.entities.add({
        polyline: {
        positions: Cesium.Cartesian3.fromDegreesArray([startingNode.lng, startingNode.lat, endingNode.lng, endingNode.lat]),
        width: 6,
        material: Cesium.Color.fromCssColorString("#f97316").withAlpha(1.0),
        clampToGround: true
      }
      });

      exploredEdges.push(explored);
    }


    // Dijkstra (no animation)
    function runDijkstraInstant(startId, endId) {
      const distances = new Map();
      const previous  = new Map();
      const remaining = new Set(adjacencyList.keys());

      adjacencyList.forEach((_, id) => distances.set(id, Infinity));
      distances.set(startId, 0);

      while (remaining.size > 0) {
        let bestNode = null;
        let bestDist = Infinity;
        for (const nodeId of remaining) {
          const currentDistance = distances.get(nodeId);
          if (currentDistance < bestDist) {
            bestDist = currentDistance;
            bestNode = nodeId;
          }
        }

        if (bestNode === null || bestDist === Infinity) {
          break;
        }
        remaining.delete(bestNode);
        if (bestNode === endId) {
          break;
        }
        const neighbors = adjacencyList.get(bestNode) || [];
        for (const { to, weight } of neighbors) {
          if (!remaining.has(to)) {
            continue;
          }
          const alt = bestDist + weight;
          if (alt < distances.get(to)) {
            distances.set(to, alt);
            previous.set(to, bestNode);
          }
        }
      }

      const path = [];
      let currentNode = endId;
      if (!previous.has(currentNode) && currentNode !== startId) {
        // no path found
        return { path: [], distance: Infinity };
      }

      while (currentNode !== undefined) {
        path.unshift(currentNode);
        if (currentNode === startId) {
          break;
        }
        currentNode = previous.get(currentNode);
      }

      return { path, distance: distances.get(endId) };
    }

    // Dijkstra (animated)
    async function runDijkstraWithAnimation(startId, endId) {
      dijkstraIsRunning = true;
      clearExplorationVisuals();
      clearShortestPath();

      const distances = new Map();
      const previous  = new Map();
      const remaining = new Set(adjacencyList.keys());

      adjacencyList.forEach((_, id) => distances.set(id, Infinity));
      distances.set(startId, 0);

      let stepCounter = 0;

      while (remaining.size > 0) {
        let bestNode = null;
        let bestDist = Infinity;
        for (const nodeId of remaining) {
          const currentDistance = distances.get(nodeId);
          if (currentDistance < bestDist) {
            bestDist = currentDistance;
            bestNode = nodeId;
          }
        }

        if (bestNode === null || bestDist === Infinity) {
          break;
        }
        remaining.delete(bestNode);

        stepCounter += 1;
        showCurrentNodeMarker(bestNode);
        statusText.textContent = `Dijkstra step ${stepCounter}: visiting node ${bestNode} (dist ≈ ${bestDist.toFixed(1)} m)`;

        // Waiting to show djikstras decision making
        await wait(3);

        if (bestNode === endId) {
          break;
        }
        const neighbors = adjacencyList.get(bestNode) || [];
        for (const { to, weight } of neighbors) {
          if (!remaining.has(to)) {
            continue;
          }
          const alt = bestDist + weight;
          if (alt < distances.get(to)) {
            distances.set(to, alt);
            previous.set(to, bestNode);
            // visually show that we found a "better" way to reach this neighbor
            addExploredEdge(bestNode, to);
            // Delay to show dijkstra's decision process
            await wait(1);
          }
        }
      }

      const path = [];
      let currentNode = endId;
      if (!previous.has(currentNode) && currentNode !== startId) {
        dijkstraIsRunning = false;
        return { path: [], distance: Infinity };
      }

      while (currentNode !== undefined) {
        path.unshift(currentNode);
        if (currentNode === startId) {
          break;
        }
        currentNode = previous.get(currentNode);
      }

      const finalDistance = distances.get(endId);
      dijkstraIsRunning = false;
      return { path, distance: finalDistance };
    }

    // Path rendering and metrics
    function clearShortestPath() {
      if (pathPolyline && viewerInstance) {
        viewerInstance.entities.remove(pathPolyline);
        pathPolyline = null;
      }
      metricsPanel.textContent = "";
    }

    function drawShortestPath(pathIds, totalDistanceMeters) {
      clearShortestPath();
      if (!pathIds || pathIds.length === 0) {
        return;
      }
      const rawCoords = [];
      pathIds.forEach(id => {
        const node = nodesById.get(id);
        rawCoords.push(node.lng, node.lat);
      });

      pathPolyline = viewerInstance.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray(rawCoords),
          width: 12,
            material: new Cesium.PolylineOutlineMaterialProperty({
              color: Cesium.Color.fromCssColorString("#0A84FF"),      // Apple Maps route blue
              outlineColor: Cesium.Color.fromCssColorString("#003E7C"), // subtle halo
              outlineWidth: 4
          }),
          clampToGround: true
        }
      });

      // quick and dirty walking time estimate
      const timeMinutes = (totalDistanceMeters / walkSpeedOfNormalHumanBeing) / 60 * 1.4;
      metricsPanel.innerHTML =
        `<strong>Path length:</strong> ${totalDistanceMeters.toFixed(1)} m<br>` +
        `<strong>Est. walk time:</strong> ${timeMinutes.toFixed(1)} min<br>` +
        `<strong>Nodes on path:</strong> ${pathIds.length}`;
    }

    async function handleClickLogic(lonDeg, latDeg) {
      const nearestId = findNearestNode(lonDeg, latDeg);
      if (nearestId === null) {
        return;
      }
      // start from user's nearest node
      if (startPathFromUser && userLatitude !== null && userLongitude !== null) {
        const userStartId = findNearestNode(userLongitude, userLatitude);
        startNodeId = userStartId;
        endNodeId = nearestId;

        statusText.textContent =
          `Start: user location (node ${startNodeId}), End: ${endNodeId}. ` +
          (animateDijkstra ? "Running Dijkstra with animation…" : "Computing shortest path…");

        let result;
        if (animateDijkstra) {
          result = await runDijkstraWithAnimation(startNodeId, endNodeId);
        } else {
          clearExplorationVisuals();
          result = runDijkstraInstant(startNodeId, endNodeId);
          if (result.path.length) {
            showCurrentNodeMarker(endNodeId);
          }
        }

        if (!result.path.length || !isFinite(result.distance)) {
          statusText.textContent = "No path found between those nodes.";
          clearShortestPath();
          return;
        }

        statusText.textContent =
          `Shortest path found (${result.path.length} nodes).`;
        drawShortestPath(result.path, result.distance);
        return;
      }

      // Normal click flow:
      // 1st click start
      // 2nd click end + run algorithm
      // 3rd click treat as new start
      if (startNodeId === null) {
        startNodeId = nearestId;
        endNodeId = null;
        clearExplorationVisuals();
        clearShortestPath();
        statusText.textContent =
          `Start node set to ${startNodeId}. Click another point for the destination.`;
      } else if (endNodeId === null) {
        endNodeId = nearestId;
        statusText.textContent =
          `Start: ${startNodeId}, End: ${endNodeId}. ` +
          (animateDijkstra ? "Running Dijkstra with animation…" : "Computing shortest path (instant)…");

        let result;
        if (animateDijkstra) {
          result = await runDijkstraWithAnimation(startNodeId, endNodeId);
        } else {
          clearExplorationVisuals();
          result = runDijkstraInstant(startNodeId, endNodeId);
          if (result.path.length) {
            showCurrentNodeMarker(endNodeId);
          }
        }

        if (!result.path.length || !isFinite(result.distance)) {
          statusText.textContent = "No path found between those nodes.";
          clearShortestPath();
          return;
        }

        statusText.textContent =
          `Shortest path found (${result.path.length} nodes).`;
        drawShortestPath(result.path, result.distance);
      } else {
        // 3rd click resets the start node to whatever was clicked
        startNodeId = nearestId;
        endNodeId = null;
        clearExplorationVisuals();
        clearShortestPath();
        statusText.textContent = `Start node changed to ${startNodeId}. Click again to pick a new destination.`;
      }
    };

    // Mouse interaction
    function setupMouseInteraction() {
      const eventHandler = new Cesium.ScreenSpaceEventHandler(
        viewerInstance.scene.canvas
      );

      const mapClick = eventHandler.setInputAction(async function(click) {
        if (dijkstraIsRunning) {
          statusText.textContent = "Dijkstra is already running, hang on a sec…";
          return;
        }

        const cartesian = viewerInstance.scene.pickPosition(click.position) ||
          viewerInstance.camera.pickEllipsoid(
            click.position,
            viewerInstance.scene.globe.ellipsoid
          );

        if (!cartesian) {
          return;
        }
        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        const lonDeg = Cesium.Math.toDegrees(cartographic.longitude);
        const latDeg = Cesium.Math.toDegrees(cartographic.latitude);
        console.log("Clicked coords:", { lat: latDeg, long: lonDeg });

        handleClickLogic(lonDeg, latDeg);
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // Reset button, clear everything and go back to the "loaded" state
      resetButton.addEventListener("click", () => {
        if (dijkstraIsRunning) {
          return;
        }
        startNodeId = null;
        endNodeId = null;
        clearExplorationVisuals();
        clearShortestPath();
        statusText.textContent =
          `Graph loaded: ${graphNodes.length} nodes, ${graphEdges.length} edges.`;
      });

      // Hide/show the full road graph
      toggleEdgesButton.addEventListener("click", () => {
        showAllEdges = !showAllEdges;
        setRoadVisibility(showAllEdges);
      });

      // Flip between animated and non-animated Dijkstra
      toggleAnimationButton.addEventListener("click", () => {
        animateDijkstra = !animateDijkstra;
        toggleAnimationButton.textContent =
          `Animation: ${animateDijkstra ? "ON" : "OFF"}`;
      });
    }

    function setupGeolocationButtons() {
      whereAmIButton.addEventListener("click", () => {
        if (!navigator.geolocation) {
          alert("Your browser does not support geolocation.");
          return;
        }

        // clear any old watch
        if (usersLocation !== null) {
          navigator.geolocation.clearWatch(usersLocation);
          usersLocation = null;
        }

        usersLocation = navigator.geolocation.watchPosition(
          handleGeolocationSuccess,
          handleGeolocationError,
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
          }
        );
      });

      startFromUserButton.addEventListener("click", () => {
        startPathFromUser = !startPathFromUser;
        startFromUserButton.textContent = startPathFromUser
          ? "Start path from user ON"
          : "Start path from first click ON";
      });
    }

    function handleGeolocationSuccess(position) {
      userLatitude  = position.coords.latitude;
      userLongitude = position.coords.longitude;

      const userCartesian = Cesium.Cartesian3.fromDegrees(userLongitude, userLatitude);

      if (!userMarker) {
        userMarker = viewerInstance.entities.add({
          position: userCartesian,
          point: {
            pixelSize: 16,
            color: Cesium.Color.RED,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            disableDepthTestDistance: Number.POSITIVE_INFINITY
          }
        });
      } else {
        userMarker.position = userCartesian;
      }

      // Automatically fly to the user once
      if (!hasCenteredOnUser) {
        viewerInstance.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            userLongitude,
            userLatitude,
            1500.0
          ),
          duration: 1.5
        });
        hasCenteredOnUser = true;
      }
    }

    function handleGeolocationError(error) {
      console.error("Error getting user location", error);
      alert("Could not get your current location: " + error.message);

      if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
    }

    function findNearestNode(lonDeg, latDeg) {
      let bestId = null;
      let bestDist = Number.POSITIVE_INFINITY;

      for (const node of graphNodes) {
        const dLon = lonDeg - node.lng;
        const dLat = latDeg - node.lat;
        const distance = Math.sqrt(dLon * dLon + dLat * dLat);
        if (distance < bestDist) {
          bestDist = distance;
          bestId = node.id;
        }
      }
      return bestId;
    }

    // Cesium and loading the JSON
    (async function startApp() {
        setupCesiumViewer();
        await loadGraphJson();
    })();

    const container = document.getElementById("imageContainer");

    // put each location image in the sidebar
    images.forEach((item) => {
      const img = document.createElement("img");
      img.src = item.url;
      img.alt = item.name;

      // when the user clicks the image, get directions to it
      img.addEventListener("click", () => {
        handleClickLogic(item.long, item.lat);
      });

      container.appendChild(img);
    });
  </script>
</body>
</html>