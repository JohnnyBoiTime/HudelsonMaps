<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pullman Graph Builder</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 100vh;
    }
    #panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 8px 10px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 13px;
      z-index: 1000;
      max-width: 260px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }
    button {
      margin: 2px 4px 2px 0;
      font-size: 12px;
    }
    .small {
      font-size: 11px;
      color: #555;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div id="panel">
    <div><strong>HudelMaps</strong></div>
    <div id="info"></div>
    <div style="margin-top: 6px;">
      <input type="file" id="inputFile" accept=".json" style="margin-top:6px;"/> 
      <button id="resetPointsBtn">Reset points</button>
    </div>
    <div>
    </div>
  </div>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>

    // Globals for pathfinding and whatnot
    let selectedPath = [];
    let highlightSelectedPath = [];
    let startingNode = 0;
    let destinationNode = 0;
    let distanceMeters = 0;
    let timeWalkingInMinutes = 0;
    // globals for lat and long of user selected map points
    let point1 = [Number.MAX_VALUE, Number.MAX_VALUE];
    let point2 = [Number.MAX_VALUE, Number.MAX_VALUE];

    function highlightQuickestPath(path) {
      
      // Clear already existing highlights 
      highlightSelectedPath.forEach(line => map.removeLayer(line));
      highlightSelectedPath = [];

      const idLookup = new Map(nodes.map(node => [node.id, node]));    

      // Draw highlighted path along nodes between the
      // 2 selected nodes red
      for (let i = 0; i < path.length - 1; i++) {
        const startId = path[i];
        const endId = path[i + 1];
        const startNode = idLookup.get(startId);
        const endNode = idLookup.get(endId);

        const line = L.polyline(
          [
            [startNode.lat, startNode.lng],
            [endNode.lat, endNode.lng]
          ],
          {
            color: 'red',
            weight: 6,
            opacity: 0.9
          }
        ).addTo(map);

        // Make it so it is drawn above the current paths
        line.bringToFront();
        highlightSelectedPath.push(line);
      }

    }

    function createPath(node) {

      // Selecting first node
      if (selectedPath.length == 0) {
        selectedPath = [node];
        return;
      }

      // Selecting second node -> compute path
      //if (selectedPath.length == 1 && selectedPath[0] != node) {
      else {
        selectedPath[1] = node;
        startingNode = selectedPath[0];
        destinationNode = selectedPath[1];
        
        // Compute shortest path
        const resultForPath = djikstras(startingNode, destinationNode);

        distanceMeters = resultForPath.distance;
        timeWalkingInMinutes = (distanceMeters / walkSpeedOfNormalHumanBeing) / 60 * 1.5;

        highlightQuickestPath(resultForPath.path);

        updateInfo();

        // Reset so user can find a new destination to and from
        // if needed
        return;

        // If more than 2 nodes are selected, reset to current node
      }
    }

    function adjacencyList() {
      const adjacencyList = new Map();

      nodes.forEach(node => {
        adjacencyList.set(node.id, []);
      });

      edges.forEach(edge => {
        const {from, to, distanceMeters} = edge;

        adjacencyList.get(from).push({to, weight: distanceMeters});
        adjacencyList.get(to).push({to: from, weight: distanceMeters});
      })

      return adjacencyList;
    }
    
      // Simple djikstra implementation
      function djikstras(startingNodeId, endingNodeId) {
        const adjacency = adjacencyList();
        const distanceMap = new Map();
        const previousNodeMap = new Map();
        const unvisitedNodes = new Set(adjacency.keys());

        unvisitedNodes.forEach(id => distanceMap.set(id, Infinity));
        distanceMap.set(startingNodeId, 0);

        while (unvisitedNodes.size > 0) {
          let currentNodeId = null;
          let currentDistance = Infinity;

          for (const nodeId of unvisitedNodes) {
            const dist = distanceMap.get(nodeId);
            if (dist < currentDistance) {
              currentDistance = dist;
              currentNodeId = nodeId;
            }
          }

          // Unreachable nodes!!!
          if (currentNodeId == null || currentDistance === Infinity) {
            break;
          }

          unvisitedNodes.delete(currentNodeId);

          if (currentNodeId == endingNodeId) {
            break;
          }
          const neighbors = adjacency.get(currentNodeId) || [];
          neighbors.forEach(({ to, weight}) => {
            if (!unvisitedNodes.has(to)) {
              return;
            }
            const alternative = currentDistance + weight;
            if (alternative < distanceMap.get(to)) {
              distanceMap.set(to, alternative);
              previousNodeMap.set(to, currentNodeId);
            }
          });
        }


      const path = [];
      let end = endingNodeId;
      path.push(end);
      while (end !== startingNodeId) {
        end = previousNodeMap.get(end);
        if (end === undefined) {
          break;
        }

        path.push(end);
      }
      path.reverse();

      return {
        distance: distanceMap.get(endingNodeId),
        path: path
      };
    }

      function findNearestNode(lat, lng) {
        if (nodes.length === 0) {
          alert("No graph loaded! Please upload a JSON file first.");
          return [-1, 0, 0];
        }

        return calculateNearest(nodes, lat, lng);
      }

      function calculateNearest(nodeList, lat, lng) {
        let minDist = Number.MAX_VALUE;
        let minNodeID = -1;
        let minLat = -1;
        let minLng = -1;

        for (const node of nodeList) {
          const candidate = Math.sqrt((lat - node.lat) ** 2 + (lng - node.lng) ** 2);
          if (candidate < minDist) {
            minDist = candidate;
            minNodeID = node.id;
            minLat = node.lat;
            minLng = node.lng;
          }
        }
        return [minNodeID, minLat, minLng];
      }

      function loadGraphFromExistingJson(graph) {
        // Copy over the JSON's node and edge data
        nodes = graph.nodes;
        edges = graph.edges;

        // Clear map data for re-adding new data
        markers.forEach(marker => map.removeLayer(marker));
        lines.forEach(line => map.removeLayer(line));
        markers = [];
        lines = [];

        // Map for quick lookups
        const findNodeById = new Map();
        nodes.forEach(node => findNodeById.set(node.id, node));

        // Add nodes as lightweight circleMarkers
        nodes.forEach(node => {
          const circle = L.circleMarker([node.lat, node.lng], {
            radius: 4,
            fillColor: '#3388ff',
            color: '#3388ff',
            weight: 1,
            fillOpacity: 0.8
          }).addTo(map);

          circle.on('click', () => createPath(node.id));
          circle.bindTooltip(`Node ${node.id}`, { direction: 'top', offset: [0, -5] });

          markers.push(circle);
        });

        // Draw edges
        edges.forEach(edge => {
          const startNode = findNodeById.get(edge.from);
          const destinationNode = findNodeById.get(edge.to);

          const distanceMeters = edge.distanceMeters;
          totalDistanceWalkedMeters += distanceMeters;

          const lineBetweenNodes = L.polyline(
            [
              [startNode.lat, startNode.lng],
              [destinationNode.lat, destinationNode.lng]
            ],
            { weight: 4 }
          ).addTo(map);

          lines.push(lineBetweenNodes);
        });

        updateInfo();
      }

        const inputFile = document.getElementById('inputFile');

        inputFile.addEventListener('change', function(event) {
          const file = event.target.files[0];

          if (!file) {
            return;
          }

          const fileReader = new FileReader();
          fileReader.onload = function(e) {
            try {
              const text = e.target.result;
              const graphData = JSON.parse(text);
              loadGraphFromExistingJson(graphData);
              alert('Loaded graph yay!!!');
            } catch (error) {
              alert('Could not parse JSON file:' + error.message);
            }
          };
          fileReader.readAsText(file);
        });

        const map = L.map('map', {
          zoomControl: false
        }).setView([46.731, -117.165], 14);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const infoDiv = document.getElementById('info');
        const resetPointsBtn = document.getElementById('resetPointsBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        const walkSpeedOfNormalHumanBeing = 1.4; // 1.4 meters/second

        let nodes = [];
        let edges = [];

        let markers = [];
        let lines = [];

        let totalDistanceWalkedMeters = 0; // In meters

        function updateInfo() {
          const totalDistanceInKM = (totalDistanceWalkedMeters / 1000);
          const totalTimeWalkingInMinutes = ((totalDistanceWalkedMeters / walkSpeedOfNormalHumanBeing)) / 60 * 1.5; // 1.5 factor for turns to make it more in line with google maps
          infoDiv.innerHTML = `Click on any two markers to see the distance between them and how long it will take to walk between them!<br>` +
          `Nodes: ${nodes.length} <br>` + 
          `Edges: ${edges.length}.<br>` + 
          `Total distance to destinaton: ${distanceMeters.toFixed(2)}m <br>` + 
          `Approximate walk time: ${timeWalkingInMinutes.toFixed(2)} minutes <br>` +
          `Point 1: ` + ((point1[0] === Number.MAX_VALUE && point1[1] === Number.MAX_VALUE) ? 
            'Not selected <br>' : `${point1[0]}, ${point1[1]}<br>`) + 
          `Point 2: ` + ((point2[0] === Number.MAX_VALUE && point2[1] === Number.MAX_VALUE) ? 
            'Not selected <br>' : `${point2[0]}, ${point2[1]}<br>`);
        }

        function resetPoints() {
          point1 = [Number.MAX_VALUE, Number.MAX_VALUE];
          point2 = [Number.MAX_VALUE, Number.MAX_VALUE];
          selectedPath = [];
          highlightSelectedPath.forEach(line => map.removeLayer(line));
          updateInfo();
        }

        // event listener for clicking on the map
        map.on('click', async function(e) {
          // if both points are unchosen, set point1
          if ((point1[0] == Number.MAX_VALUE && point1[1] == Number.MAX_VALUE) && 
            (point2[0] == Number.MAX_VALUE && point2[1] == Number.MAX_VALUE)) {
              console.log("YIPEEEE");
              const [nearestNodeId, nodeLat, nodeLng] = findNearestNode(e.latlng.lat, e.latlng.lng);
              createPath(nearestNodeId);
              point1[0] = e.latlng.lat;
              point1[1] = e.latlng.lng;
          }
          else {
              const [nearestNodeId, nodeLat, nodeLng] = findNearestNode(e.latlng.lat, e.latlng.lng);
              point2[0] = e.latlng.lat;
              point2[1] = e.latlng.lng;
              createPath(nearestNodeId);
          }
          const lat = e.latlng.lat;
          const lng = e.latlng.lng;

          console.log("Clicked at:", lat, lng);

          // Example: find nearest node
          const [nearestNodeId, nodeLat, nodeLng] = findNearestNode(lat, lng);
          console.log("Nearest node:", nearestNodeId, "at", nodeLat, nodeLng);

          // Optional: do something else with the click coordinates
          updateInfo();
      });

        resetPointsBtn.addEventListener('click', resetPoints);
        updateInfo();
  </script>
</body>
</html>
